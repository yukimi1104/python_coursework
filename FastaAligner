#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Title: FastaAligner.py
Author: Yiran Chen
Version: 1.0
Date: 2025-10-15

Description:
    Evaluate how well aligned DNA sequences match each other by calculating total 
    alignment score at each given position. This program loads and reads a FASTA 
    input file containing two or more pre-aligned sequences with equal length
    and using optional input parameter file or default scores for 
    matches, transitions, transversions, and gaps.
    Default scoring according to the test question as:
    MATCH=+1
    TRANSITION=-1
    TRANSVERSION=-2
    GAP=-1
List of functions:
    - read_fasta(path): Read fasta file with header and sequences.
    - parse_params(path): Parse parameters for scoring from txt file or default.
    - validate_aligned(seq): Ensure only 'ACTGactg-" are in sequences.
    - score_pair(s1, s2, params): Calculate identity, gaps, and score.
    - format_result(id1, id2, L):Produce a structured summary string for each pair.
Procedure:
    1. Read FASTA file and (optional) parameters.txt.
    2. Validate that sequences have equal length and only in "ACTGactg-".
    3. Compare each pair of sequences from start to end.
    4. Print results to screen and (optionally) save to output file.
Input:
    - FASTA file(input_fasta.fna) with no less than 2 aligned DNA sequences (A,C,G,T,‘-’)
    - Optional parameters.txt (contains parameters for match, transition, 
      transversion,gap)
Output:
    - Screen output+ optional output text file(output_fasta.txt) showing percentage
      of identity, gap and score
Usage:
   python FastaAligner.py input_fasta.fna parameters.txt [optional] output_fasta.txt [optional]
"""
#!/usr/bin/env python3

import sys

#Here are default settings of scoring parameters, transition types and valid characters
PARAM_DEFAULT = {"MATCH": 1, "TRANSITION": -1, "TRANSVERSION": -2, "GAP": -1}
TRANSITIONS ={("A", "G"), ("G", "A"), ("C", "T"), ("T", "C")} #create a set of different kinds of transitions between bases
VALID_BASE = set("ACGT-")  # all using upperletter


#%% The function of reading input fasta file
def read_fasta(path):
    #The aim is to create a dict seqs{id: seq} with characters uppercased and spaces removed.
    seqs = {}
    header=None
    parts=[] 
    with open(path, "r") as fin:
        for line in fin:
            line = line.strip()
            if not line:  #remove empty lines
                continue
            if line.startswith(">"): #make sure header start with ">"
                if header is not None: #the first loop header is none, so we should add the last one below
                    seqs[header] = "".join(parts).replace(" ", "").upper()
                header = line[1:].split()[0] #skip ">" and extract IDs
                parts = [] #clean the sequences for a new ID
            else:
                parts.append(line.replace(" ", "")) #join the sequence lines of an ID
        if header is not None:
            seqs[header] = "".join(parts).replace(" ", "").upper() #join the sequence lines of the last ID
    return seqs #return the dictionary, key are IDs,values are sequences


#%% the function of getting parameters for scoring
def parse_params(path):
    params = PARAM_DEFAULT.copy() #avoid change of default values
    with open(path, "r") as fh:
        for line in fh:
            line = line.strip() #remove whitespace
            if not line or line.startswith("#") or "=" not in line: 
                continue
            ''' skip empty lines,lines for clarification(start with s),and
                lines do not have a value for scoring(without "=")'''
            key, value = line.split("=", 1)#split types and values
            key, value = key.strip().upper(), value.strip() #remove whitespaces and all upperletters
            if key in params: #if we have a parameter.txt, using values inside instead of default values
                try:
                    params[key] = int(value)
                except ValueError: 
                    pass  #e.g.,if the value is a string or other wrong parameters, remains default
    return params


#%% Validation of DNA sequences input
def validate_aligned(obj):
    if isinstance(obj, dict):#make sure the reading results is stored in a dict 
        ids = list(obj.keys()) #get ids
        seqs = [obj[i] for i in ids] #get sequences(values)
    elif isinstance(obj, (list, tuple)):#if the input data are list or tuple
        seqs = list(obj)
        ids = [str(i + 1) for i in range(len(seqs))] 
    if len(seqs) < 2: 
        raise ValueError("No less than two aligned sequences should be in input_fasta.fna.")
    L = len(seqs[0]) #the length of the first sequence
    for s in seqs:
        if len(s)!= L:
            raise ValueError("Sequences are not in equal length.")
    for idx in range(len(seqs)):  #iterate sequences and mark the index of sequence with invalid character 
        s = seqs[idx] 
        for ch in s:
            if ch not in VALID_BASE:
                raise ValueError(f"Invalid character '{ch}' in sequence {ids[idx]}.")
    return ids, seqs, L


#%% the function of scoring for each alignment of bases pair
def score_pair(s1, s2, params):
    if len(s1) != len(s2): #check length
        raise ValueError("Sequences must have equal length.")
    s1, s2 = s1.upper(), s2.upper() #all upperletter
    L = len(s1)
    idn = 0 #identity
    gaps = 0 #gap
    score = 0 #total score
    for i in range(L):#iterate each pair
        a, b = s1[i], s2[i]
        if a == "-" and b == "-":
            continue  #skip both gaps
        if a == "-" or b == "-":
            gaps += 1  #find a gap 
            score += params["GAP"] #using gap paramter
            continue
        if a == b:
            idn += 1 #find identity pair
            score += params["MATCH"] #using identity parameter
        else:
            if (a, b) in TRANSITIONS: #find transition
                score += params["TRANSITION"]
            else:                    #the left are tranversions
                score += params["TRANSVERSION"]
    idp = (idn / L * 100)  #dividing with total length to calculate relative percentage
    gpp = (gaps / L * 100) 
    return idn, idp, gaps, gpp, score, L
#%% the function of formatting the result
def format_result(id1, id2, res):
    idn, idp, gaps, gpp, score, L = res #tuple unpacking for separate values
    return f"{id1}-{id2}: Identity: {idn}/{L} ({idp:.1f}%), Gaps: {gaps}/{L} ({gpp:.1f}%), Score={score}"
#%% The function of validating inputs, handling errors, scoring, printing results, and optionally writing an output file.
def main(): #check the command
    if len(sys.argv) < 2 or len(sys.argv) > 4:
        print("Usage: python FastaAligner.py input_fasta.fna [parameters.txt] [output_fasta.txt]")
        return
    input_fasta = sys.argv[1] #input path
    params = PARAM_DEFAULT.copy() #copy the original default param
    out_path = sys.argv[3] if len(sys.argv) == 4 else None #optional output path
#if the length>=3, there may be user-defined parameters.txt
    if len(sys.argv) >= 3:
        param_file = sys.argv[2]
        try:
            params = parse_params(param_file)
        except FileNotFoundError:
            print(f"Warning: parameters file '{param_file}' does not exist. Default used.")
#read the input file, validation id and requences
    try:
        recs = read_fasta(input_fasta)              
        ids, seqs, L = validate_aligned(recs)  
        lines = []
        n = len(ids) #the total number of ids
        for i in range(n - 1): #start from position 0{first position}
            id1, s1 = ids[i], seqs[i] #iterate each position
            for j in range(i + 1, n):
                id2, s2 = ids[j], seqs[j]
                res = score_pair(s1, s2, params) #scoring
                lines.append(format_result(id1, id2, res)) #formatting 
        for l in lines: #print each sequences pairs result
            print(l)
        if out_path: #if optional output file
            with open(out_path, "w") as out:
                out.write("\n".join(lines) + "\n") #"\n" at each line end
    except FileNotFoundError as e: #if file does not found
        print(f"File {e.filename} does not exist.")
    except ValueError as e:
    # Input content is wrong: unequal length, illegal characters, too few sequences, bad params values.
        print(f"[ValueError] {e}")
    except TypeError as e:
    # Wrong types passed into functions (e.g., single string instead of dict)
        print(f"[TypeError] {e}")
    except IndexError as e:
    # Likely a coding/indexing mistake (ids or sequences length mismatch, dict indexed like a list)
        print(f"[IndexError] {e}")
if __name__ == "__main__":
    main()


