#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Title: FastaAligner.py
Author: Yiran Chen
Version: 1.0
Date: 2025-10-15

Description:
    Evaluate how well aligned DNA sequences match each other by calculating total 
    alignment score at each given position. This program loads and reads a FASTA 
    input file containing two or more pre-aligned sequences with equal length
    and using optional input parameter file or default scores for 
    matches, transitions, transversions, and gaps.
    Default scoring according to the test question as:
    MATCH=+1
    TRANSITION=-1
    TRANSVERSION=-2
    GAP=-1
List of functions:
    - read_fasta(path): Read fasta file with header and sequences.
    - parse_params(path): Parse parameters for scoring from txt file or default.
    - validate_align(seq): Ensure only 'ACTGactg-" are in sequences.
    - score_pair(s1, s2, params): Calculate identity, gaps, and score.
    - format_result(id1, id2, res):Produce a structured summary string for each pair.
Procedure:
    1. Read FASTA file and (optional) parameters.txt.
    2. Validate that sequences have equal length and only in "ACTGactg-".
    3. Compare each pair of sequences from start to end.
    4. Print results to screen and (optionally) save to output file.
Input:
    - FASTA file(input_fasta.fna) with no less than 2 aligned DNA sequences (A,C,G,T,‘-’)
    - Optional parameters.txt (contains parameters for match, transition, 
      transversion,gap)
Output:
    - Screen output+ optional output text file(output_fasta.txt) showing percentage
      of identity, gap and score
Usage:
   python FastaAligner.py input_fasta.fna parameters.txt [optional] output_fasta.txt [optional]
"""
#!/usr/bin/env python3

import sys

#Here are default settings of scoring parameters, transition types and valid characters
PARAM_DEFAULT = {"MATCH": 1, "TRANSITION": -1, "TRANSVERSION": -2, "GAP": -1}
TRANSITIONS ={("A", "G"), ("G", "A"), ("C", "T"), ("T", "C")} #create a set of different kinds of transitions between bases
VALID_BASE = set("ACGT-")  # all using upperletter


# ----- FASTA -----
def read_fasta(path):
    """Return dict {id: seq} with sequences uppercased and spaces removed."""
    seqs = {}
    hdr, parts = None, []
    with open(path, "r", encoding="utf-8") as fh:
        for raw in fh:
            line = raw.strip()
            if not line:
                continue
            if line.startswith(">"):
                if hdr is not None:
                    seqs[hdr] = "".join(parts).replace(" ", "").upper()
                hdr = line[1:].split()[0]
                parts = []
            else:
                parts.append(line.replace(" ", ""))
        if hdr is not None:
            seqs[hdr] = "".join(parts).replace(" ", "").upper()
    return seqs


# ----- Parameters -----
def parse_params(path):
    """Read key=value lines to override defaults. Unknown keys are ignored."""
    params = PARAM_DEFAULT.copy()
    with open(path, "r", encoding="utf-8") as fh:
        for raw in fh:
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            k, v = line.split("=", 1)
            k, v = k.strip().upper(), v.strip()
            if k in params:
                try:
                    params[k] = int(v)
                except ValueError:
                    pass  # 非整数则保持默认
    return params


# ----- Validation -----
def validate_aligned(obj):
    """
    接受 dict {id: seq} 或可迭代的序列列表，验证：
    1) 至少两条；2) 等长；3) 仅含 VALID_BASE。
    返回 (ids, seqs, L) —— 规范化后的 id 列表、序列列表、共同长度。
    """
    if isinstance(obj, dict):
        ids = list(obj.keys())
        seqs = [obj[i] for i in ids]
    else:
        seqs = list(obj)
        ids = [str(i + 1) for i in range(len(seqs))]

    if len(seqs) < 2:
        raise ValueError("At least two aligned sequences are required.")

    L = len(seqs[0])
    for s in seqs:
        if len(s) != L:
            raise ValueError("Sequences are not of equal length.")

    for idx in range(len(seqs)):
        s = seqs[idx]
        for ch in s:
            if ch not in VALID_BASE:
                raise ValueError(f"Invalid character '{ch}' found in sequence {ids[idx]}.")

    return ids, seqs, L


# ----- Scoring -----
def score_pair(s1, s2, params):
    """Return (idn, idp, gaps, gpp, score, L)."""
    if len(s1) != len(s2):
        raise ValueError("Sequences must have equal length.")
    s1, s2 = s1.upper(), s2.upper()
    L = len(s1)

    idn = 0
    gaps = 0
    score = 0

    # 不使用 zip：基于索引逐位比较
    for i in range(L):
        a, b = s1[i], s2[i]
        if a == "-" and b == "-":
            continue  # 双缺口记 0 分
        if a == "-" or b == "-":
            gaps += 1
            score += params["GAP"]
            continue
        if a == b:
            idn += 1
            score += params["MATCH"]
        else:
            if (a, b) in TRANSITIONS:
                score += params["TRANSITION"]
            else:
                score += params["TRANSVERSION"]

    idp = (idn / L * 100) if L else 0.0
    gpp = (gaps / L * 100) if L else 0.0
    return idn, idp, gaps, gpp, score, L


def format_result(id1, id2, res):
    idn, idp, gaps, gpp, score, L = res
    return f"{id1}-{id2}: Identity: {idn}/{L} ({idp:.1f}%), Gaps: {gaps}/{L} ({gpp:.1f}%), Score={score}"


# ----- CLI -----
def main():
    if len(sys.argv) < 2 or len(sys.argv) > 4:
        print("Usage: python FastaAligner.py input_fasta.fna [parameters.txt] [output_fasta.txt]")
        return

    in_fna = sys.argv[1]
    params = PARAM_DEFAULT.copy()
    out_path = sys.argv[3] if len(sys.argv) == 4 else None

    if len(sys.argv) >= 3:
        pfile = sys.argv[2]
        try:
            params = parse_params(pfile)
        except FileNotFoundError:
            print(f"Warning: parameters file '{pfile}' not found. Using defaults.")

    try:
        recs = read_fasta(in_fna)              # {id: seq}
        ids, seqs, _ = validate_aligned(recs)  # 统一校验

        # 逐对计分（不使用 zip / itertools）
        lines = []
        n = len(ids)
        for i in range(n - 1):
            id1, s1 = ids[i], seqs[i]
            for j in range(i + 1, n):
                id2, s2 = ids[j], seqs[j]
                res = score_pair(s1, s2, params)
                lines.append(format_result(id1, id2, res))

        for ln in lines:
            print(ln)

        if out_path:
            with open(out_path, "w", encoding="utf-8") as out:
                out.write("\n".join(lines) + "\n")

    except FileNotFoundError as e:
        print(f"File {e.filename} not found!")
    except (TypeError, ValueError, IndexError) as e:
        print("Error:", e)


if __name__ == "__main__":
    main()


